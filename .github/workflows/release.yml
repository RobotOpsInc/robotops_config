name: Release

on:
  workflow_dispatch:
    # Manual trigger only - production releases from main branch only
    inputs:
      dry_run:
        description: 'Dry run (validate without creating release)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: '189676910689'
  DEPLOY_ROLE: arn:aws:iam::189676910689:role/github-actions-deploy-production
  CLOUDFRONT_DISTRIBUTION_ID: E3QAA3BBMD2WVG
  APT_BUCKET: robotops-apt-pub-production
  CODEARTIFACT_DOMAIN: robotops
  CODEARTIFACT_REPO: robotops-cargo

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed to create releases and tags
    steps:
      - uses: actions/checkout@v4

      - name: Ensure release is from main branch
        run: |
          if [[ "${{ github.ref }}" != "refs/heads/main" ]]; then
            echo "::error::Production releases can only be created from main branch"
            echo "Current branch: ${{ github.ref }}"
            echo "For development releases, use the Release Development workflow"
            exit 1
          fi
          echo "ðŸ“¦ Production release from main branch"

      - name: Get version from VERSION file
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Check tag doesn't already exist
        run: |
          if git ls-remote --tags origin | grep -q "refs/tags/${{ steps.version.outputs.tag }}$"; then
            echo "::error::Tag ${{ steps.version.outputs.tag }} already exists"
            exit 1
          fi

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Extract section between "## [VERSION]" and the next "## [" or end of file
          CHANGELOG=$(awk -v ver="$VERSION" '
            /^## \[/ {
              if (found) exit
              if ($0 ~ "\\[" ver "\\]") found=1
            }
            found { print }
          ' CHANGELOG.md)

          # Write to file for gh release
          echo "$CHANGELOG" > release_notes.md

          echo "Extracted changelog:"
          cat release_notes.md

      - name: Create GitHub Release
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release create "${{ steps.version.outputs.tag }}" \
            --title "Release ${{ steps.version.outputs.tag }}" \
            --notes-file release_notes.md

      - name: Dry run summary
        if: ${{ inputs.dry_run }}
        run: |
          echo "## Dry Run Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Would create release:" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** ${{ steps.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Title:** Release ${{ steps.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Notes" >> $GITHUB_STEP_SUMMARY
          cat release_notes.md >> $GITHUB_STEP_SUMMARY

  build-packages:
    runs-on: ${{ matrix.runner }}
    needs: release
    if: ${{ !inputs.dry_run }}
    permissions:
      contents: write  # Needed to upload release assets
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-24.04
          - arch: arm64
            runner: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install just
        run: |
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            JUST_ARCH="aarch64"
          else
            JUST_ARCH="x86_64"
          fi
          curl -sSL https://github.com/casey/just/releases/download/1.36.0/just-1.36.0-${JUST_ARCH}-unknown-linux-musl.tar.gz | tar xz -C /tmp just
          sudo mv /tmp/just /usr/local/bin/

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: robotops-config:build
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate protobuf code
        run: just generate

      - name: Build Debian package
        run: |
          docker run --rm \
            -v ${{ github.workspace }}:/ws/src/robotops-config \
            -v ${{ github.workspace }}:/output \
            robotops-config:build bash -c "
              cd /ws/src/robotops-config && \
              cp generated/ros2/package.xml . && \
              cp generated/ros2/CMakeLists.txt . && \
              mkdir -p cmake && cp generated/ros2/robotops-configConfig.cmake.in cmake/ && \
              apt-get update && \
              apt-get install -y dpkg-dev fakeroot debhelper && \
              bloom-generate rosdebian --os-name ubuntu --os-version noble --ros-distro jazzy && \
              dpkg-buildpackage -us -uc -b && \
              cp /ws/src/*.deb /output/
            "

      - name: Find built package
        id: deb
        run: |
          DEB_FILE=$(ls *.deb | head -n1)
          echo "file=$DEB_FILE" >> $GITHUB_OUTPUT
          echo "Built package: $DEB_FILE"

      - name: Validate package CMake integration
        run: |
          echo "Installing package for validation..."
          sudo dpkg -i ${{ steps.deb.outputs.file }} || sudo apt-get install -f -y

          echo "Installing build dependencies for integration test..."
          sudo apt-get install -y libprotobuf-dev

          echo "Running CMake integration tests..."
          cd test/cmake_integration
          mkdir -p build && cd build

          # Configure with ROS2 prefix
          cmake .. -DCMAKE_PREFIX_PATH=/opt/ros/jazzy

          # Build the test
          cmake --build .

          # Run the test executable
          ./test_robotops_config

          echo "âœ… All CMake integration tests passed"

      - name: Check installed files
        run: |
          echo "Verifying installation..."

          # Verify library exists
          test -f /opt/ros/jazzy/lib/librobotops-config.so || \
            { echo "âŒ Library not found"; exit 1; }
          echo "âœ“ Library found"

          # Verify headers exist
          test -f /opt/ros/jazzy/include/robotops/config/v1/config.pb.h || \
            { echo "âŒ Headers not found"; exit 1; }
          echo "âœ“ Headers found"

          # Verify CMake config exists (ament location)
          test -f /opt/ros/jazzy/share/robotops-config/cmake/robotops-configConfig.cmake || \
            { echo "âŒ CMake config not found"; exit 1; }
          echo "âœ“ CMake config found"

          # Check library links to protobuf
          ldd /opt/ros/jazzy/lib/librobotops-config.so | grep protobuf || \
            { echo "âŒ Protobuf not linked"; exit 1; }
          echo "âœ“ Protobuf linked correctly"

          echo "âœ… All file checks passed"

      - name: Upload Debian package as artifact
        uses: actions/upload-artifact@v4
        with:
          name: debian-package-${{ matrix.arch }}
          path: ${{ steps.deb.outputs.file }}
          retention-days: 1

      - name: Upload YAML config as release asset
        if: matrix.arch == 'amd64'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Upload YAML file to GitHub release with user-friendly name
          gh release upload "${{ steps.version.outputs.tag }}" \
            generated/yaml/default.yaml#config.yaml \
            --clobber

          echo "âœ… Uploaded config.yaml to release ${{ steps.version.outputs.tag }}"
          echo ""
          echo "Public download URL:"
          echo "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/config.yaml"

  publish-debian:
    runs-on: ubuntu-latest
    needs: build-packages
    if: ${{ !inputs.dry_run }}
    permissions:
      id-token: write  # Needed for AWS OIDC
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download all Debian packages
        uses: actions/download-artifact@v4
        with:
          pattern: debian-package-*
          path: ./packages
          merge-multiple: true

      - name: List downloaded packages
        run: |
          echo "Downloaded packages:"
          ls -lh ./packages/

      - name: Publish Debian packages to S3
        uses: ./.github/actions/publish-debian-s3
        with:
          deb-files: './packages/*.deb'
          apt-bucket: ${{ env.APT_BUCKET }}
          cloudfront-distribution-id: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
          gpg-passphrase: ${{ secrets.GPG_PASSPHRASE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Summary
        run: |
          echo "## Debian Package Publishing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Published Packages" >> $GITHUB_STEP_SUMMARY
          for deb in ./packages/*.deb; do
            echo "- $(basename $deb)" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… APT Repository: https://apt.robotops.com" >> $GITHUB_STEP_SUMMARY

  publish-cargo:
    runs-on: ubuntu-latest
    needs: release
    if: ${{ !inputs.dry_run }}
    permissions:
      id-token: write  # Needed for AWS OIDC
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: robotops-config:build
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate protobuf code
        run: |
          if [ -f "justfile" ]; then
            # Install just
            curl -sSL https://github.com/casey/just/releases/download/1.36.0/just-1.36.0-x86_64-unknown-linux-musl.tar.gz | tar xz -C /tmp just
            sudo mv /tmp/just /usr/local/bin/
            just generate
          else
            echo "No justfile found, skipping generation"
          fi

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Publish Cargo crate to CodeArtifact
        uses: ./.github/actions/publish-cargo-codeartifact
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-account-id: ${{ env.AWS_ACCOUNT_ID }}
          codeartifact-domain: ${{ env.CODEARTIFACT_DOMAIN }}
          codeartifact-repo: ${{ env.CODEARTIFACT_REPO }}
          cargo-package-path: ./generated/sdks/rust
